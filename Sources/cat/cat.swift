// Generated by Robert M. Lefkowitz <code@liberally.net> in 2024 using ChatGPT
// from a file containing the following notice:

/*
 * Copyright (c) 1989, 1993
 *  The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Kevin Fall.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

import CMigration

@main final class cat : ShellCommand {

  struct Flag : OptionSet {
    let rawValue: Int

    static let bflag = Flag(rawValue: 1 << 0) // 00001
    static let eflag = Flag(rawValue: 1 << 1) // 00010
    static let lflag = Flag(rawValue: 1 << 2) // 00100
    static let nflag = Flag(rawValue: 1 << 3) // 01000
    static let sflag = Flag(rawValue: 1 << 4) // 10000
    static let tflag = Flag(rawValue: 1 << 5) // 10000
    static let vflag = Flag(rawValue: 1 << 6) // 10000
  }

  struct CommandOptions {
    var flags : Flag = []
    var args : [String] = []
  }

  var rval = 0
  var filename: String = ""

  // Constants
  let PHYSPAGES_THRESHOLD = 32 * 1024
  let BUFSIZE_MAX = 2 * 1024 * 1024
  let BUFSIZE_SMALL = 65536

  var usage : String = "usage: cat [-belnstuv] [file ...]"

  func parseOptions() throws(CmdErr) -> CommandOptions {
    var options = CommandOptions()
    let supportedFlags = "belnstuv"
    let go = BSDGetopt(supportedFlags)

    while let (k, _) = try go.getopt() {
      switch k {
        case "b":
          options.flags.insert(.bflag)
          options.flags.insert(.nflag)
        case "e":
          options.flags.insert(.eflag)
          options.flags.insert(.vflag)
        case "l":
          options.flags.insert(.lflag)
        case "n":
          options.flags.insert(.nflag)
        case "s":
          options.flags.insert(.sflag)
        case "t":
          options.flags.insert(.tflag)
          options.flags.insert(.vflag)
        case "u":
            // setbuf(FileDescriptor.standardOutput.rawValue, nil) // Disable output buffering
        case "v":
          options.flags.insert(.vflag)
        default:
          throw CmdErr(1)
      }
    }
    options.args = go.remaining
    return options
  }

  func runCommand(_ options : CommandOptions) async throws(CmdErr) {

    let cooked = !options.flags.intersection([.bflag, .eflag, .nflag, .sflag, .tflag, .vflag]).isEmpty

    for path in options.args {
      if path == "-" {
        filename = "stdin"
        let fh = FileDescriptor.standardInput
        if cooked {
          cookCat(fh, options)
        } else {
          do {
            try rawCat(fh)
          } catch(let e) {
            throw CmdErr(1, "\(e)")
          }
        }
      } else {
        filename = path
        do {
          let fh = try FileDescriptor(forReading: path)
          defer { try? fh.close() }
          if cooked {
            cookCat(fh, options)
          } else {
            try rawCat(fh)
          }

        } catch(let e) {
          var se = FileDescriptor.standardError
          print("\(progname): \(path): \(e)", to: &se)
          rval = 1
        }
      }
    }
  }

  // Helper to write to stdout
  func writeToStdout(_ text: String) {
    // this would be unbuffered.
    let _ = try? FileDescriptor.standardOutput.writeAll([UInt8](text.utf8))  // writes as utf8
  }

  func cookCat(_ fileHandle: FileDescriptor, _ options : CommandOptions) {
    var line = 0
    var gobble = false
    var prev: Character = "\n"

    // Read and process file line by line
    var buffer = [UInt8]()
    while let data = try? fileHandle.readUpToCount(1), !data.isEmpty {
      buffer.append(contentsOf: data)
      guard var current = String(decoding: data, as: ISOLatin1.self).first else { continue }

      if prev == "\n" {
        if options.flags.contains(.sflag) {
          if current == "\n" {
            if gobble { continue }
            gobble = true
          } else {
            gobble = false
          }
        }

        if options.flags.contains(.nflag) {
          if !options.flags.contains(.bflag) || current != "\n" {
            writeToStdout(cFormat("%6d\t", line + 1))
            line += 1
          } else if options.flags.contains(.eflag) {
            writeToStdout("      \t")
          }
        }
      }

      if current == "\n" {
        if options.flags.contains(.eflag) { writeToStdout("$") }
      } else if current == "\t" {
        if options.flags.contains(.tflag) {
          writeToStdout("^I")
          continue
        }
      } else if options.flags.contains(.vflag) {
        if (!current.isASCII) && !current.isPrintable {
          writeToStdout("M-")
          current = Character(UnicodeScalar(data[0] & 0x7f))
        }
        if let c = current.asciiValue {
          if c < 32 {
            writeToStdout("^")
            let ctrlChar = Character(Unicode.Scalar(current.asciiValue! | 0x40))
            writeToStdout(String(ctrlChar))
          } else if c == 127 {
            writeToStdout("?")
          } else {
            writeToStdout(String(current))
          }
        }
        prev = current
        continue
      }
      writeToStdout(String(current))
      prev = current
    }
  }

  // Raw cat (direct file copy)
  func rawCat(_ fd : FileDescriptor) throws {
    let ofd = FileDescriptor.standardOutput
    while true {
      let bytes = try fd.readUpToCount(BUFSIZE_SMALL)
      if bytes.count == 0 { break }
      do {
        try ofd.write(bytes)
      } catch {
        throw CmdErr(1, "stdout")
      }
    }
  }
}

extension Character {
  var isPrintable : Bool { get {
    if let v = self.asciiValue {
      return v >= 32 && v <= 126
    }
    return false
  } }
}


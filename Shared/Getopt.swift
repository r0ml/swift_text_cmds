
// Generated by Robert M. Lefkowitz <code@liberally.net> in 2024 using ChatGPT
// from files containing the following notices:

/*
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * Copyright (c) 1987, 1993, 1994
 *  The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Copyright (c) 2002 Todd C. Miller <Todd.Miller@courtesan.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * Sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F39502-99-1-0512.
 */

/*
 * Copyright (c) 2000 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Dieter Baron and Thomas Klausner.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

import Foundation

public enum argType: Int32 {
  case no_argument = 0
  case required_argument = 1
  case optional_argument = 2
}

public struct option {
  public let name: String
  public let has_arg: argType

  public init(_ n: String, _ h: argType) {
    self.name = n
    self.has_arg = h
  }

}

public class BSDGetopt_long {

  var optind = 0

  struct GLFlags: OptionSet {
    let rawValue: UInt8

    static let FLAG_PERMUTE = GLFlags(rawValue: 0x01)
    static let FLAG_ALLARGS = GLFlags(rawValue: 0x02)
    static let FLAG_LONGONLY = GLFlags(rawValue: 0x04)
  }

  //  let FLAG_PERMUTE = 0x01  /* permute non-options to the end of argv */
  //  let FLAG_ALLARGS = 0x02  /* treat non-options as args to option "-1" */
  //  let FLAG_LONGONLY = 0x04  /* operate as getopt_long_only */

  /* return values */
  let BADARG: String

  var opterr = true

  //   #define  BADARG    ((*options == ':') ? (int)':' : (int)'?')
  let INORDER = "\u{01}"

  //   static char EMSG[] = "";
  var options: String
  var long_options: [option]
  var nargv: [String]

  var posixly_correct: Bool

  var optopt: Character = "?"
  var optarg: String = ""

  let NO_PREFIX = -1
  let D_PREFIX = 0
  let DD_PREFIX = 1
  let W_PREFIX = 2

  /* XXX: set optreset to 1 rather than these two */

  var nonopt_start = -1 /* first non option argument (for permute) */
  var nonopt_end = -1 /* first option after non options (for permute) */

  /* Error messages */
  //  let recargchar = "option requires an argument -- %c"
  //  let illoptchar = "illegal option -- %c" /* From P1003.2 */

  var dash_prefix = -1  // NO_PREFIX

  //  let gnuoptchar = "invalid option -- %c"

  //  let recargstring = "option `%s%s' requires an argument"
  //  let ambig = "option `%s%.*s' is ambiguous"
  //  let noarg = "option `%s%.*s' doesn't allow an argument"
  //  let illoptstring = "unrecognized option `%s%s'"

  var place = ""

  //  let PRINT_ERROR : Bool

  public init(
    _ s: String, _ long_options: [option],
    _ args: [String] = Array(CommandLine.arguments.dropFirst())
  ) {
    self.options = s
    self.nargv = args
    self.long_options = long_options
    optind = 0
    //    let PRINT_ERROR = opterr != 0 && options.first != ":"
    BADARG = s.first == ":" ? ":" : "?"

    // Disable GNU extensions if POSIXLY_CORRECT is set or options string begins with a '+'.
    posixly_correct = getenv("POSIXLY_CORRECT") != nil

  }

  /// Compute the greatest common divisor of a and b.
  func gcd(_ aa: Int, _ bb: Int) -> Int {
    var a = aa
    var b = bb
    var c = a % b
    while c != 0 {
      a = b
      b = c
      c = a % b
    }
    return b
  }

  /*
   * Exchange the block from nonopt_start to nonopt_end with the block
   * from nonopt_end to opt_end (keeping the same order of arguments
   * in each block).
   */
  func permute_args(
    _ panonopt_start: Int, _ panonopt_end: Int, _ opt_end: Int,
    _ nargv: inout [String]
  ) {
    //  int cstart, cyclelen, i, j, ncycle, nnonopts, nopts, pos;
    //  char *swap;

    /*
     * compute lengths of blocks and number and size of cycles
     */
    let nnonopts = panonopt_end - panonopt_start
    let nopts = opt_end - panonopt_end
    let ncycle = gcd(nnonopts, nopts)
    let cyclelen = (opt_end - panonopt_start) / ncycle

    for i in 0..<ncycle {
      let cstart = panonopt_end + i
      var pos = cstart
      for _ in 0..<cyclelen {
        if pos >= panonopt_end {
          pos -= nnonopts
        } else {
          pos += nopts
        }

        //        swap(&nargv[pos], &nargv[cstart])
        let swap = nargv[pos]
        nargv[pos] = nargv[cstart]
        nargv[cstart] = swap
      }
    }
  }

  /*
   * parse_long_options --
   *  Parse long options in argc/argv argument vector.
   * Returns -1 if short_too is set and the option does not match long_options.
   */

  func
    parse_long_options(_ short_too: Bool, _ flags: GLFlags) throws(CmdErr) -> (
      String, String
    )?
  {
    //  char *current_argv, *has_equal;

    var current_dash: String = ""

    //  size_t current_argv_len;
    //  int i, match, exact_match, second_partial_match;

    let cur_argv = place

    switch dash_prefix {
    case D_PREFIX:
      current_dash = "-"
    case DD_PREFIX:
      current_dash = "--"
    case W_PREFIX:
      current_dash = "-W "
    default:
      current_dash = ""
    }

    var match = -1
    var exact_match = false
    var second_partial_match = false

    optind += 1

    var current_key: String
    //    var current_val : String?

    let has_equal = cur_argv.firstIndex(of: "=")
    if let has_equal {
      /* argument found (--option=arg) */
      current_key = String(cur_argv.prefix(upTo: has_equal))
      //      current_val = String(cur_argv.suffix(from: has_equal).dropFirst())
    } else {
      current_key = cur_argv
    }

    for (i, opt) in long_options.enumerated() {
      /* find matching long option */
      if !opt.name.hasPrefix(current_key) {
        continue
      }

      if opt.name.count == current_key.count {
        /* exact match */
        match = i
        exact_match = true
        break
      }

      /*
       * If this is a known short option, don't allow
       * a partial match of a single character.
       */
      if short_too && current_key.count == 1 {
        continue
      }

      if match == -1 { /* first partial match */
        match = i
      } else if flags.contains(.FLAG_LONGONLY)
        || long_options[i].has_arg != long_options[match].has_arg
      {
        //               long_options[i].flag != long_options[match].flag ||
        //               long_options[i].val != long_options[match].val) {
        second_partial_match = true
      }
    }
    if !exact_match && second_partial_match {
      /* ambiguous abbreviation */
      //"option `%s%.*s' is ambiguous"
      throw CmdErr(1, "option \(current_dash)\(current_key) is ambiguous")
      //      optopt = "\0"
    }

    if match != -1 { /* option found */
      if let has_equal, long_options[match].has_arg == .no_argument {
        // FIXME: do I need to set optopt (or pass it to CmdErr)
        //"option `%s%.*s' doesn't allow an argument"
        throw CmdErr(
          1, "option \(current_dash)\(current_key) doesn't allow an argument")
        /*
         * XXX: GNU sets optopt to val regardless of flag
         */
        /*        if (long_options[match].flag == NULL) {
         optopt = long_options[match].val;
         }
         else {
         optopt = "\0"
         }
         */
      }
      if long_options[match].has_arg == .required_argument
        || long_options[match].has_arg == .optional_argument
      {
        if let has_equal {
          optarg = String(place.suffix(from: has_equal).dropFirst())
        } else if long_options[match].has_arg == .required_argument {
          // optional argument doesn't use next nargv
          optarg = nargv[optind]
          optind += 1
        }
      }
      if long_options[match].has_arg == .required_argument && optarg == "" {
        /*
         * Missing argument; leading ':' indicates no error
         * should be generated.
         */
        optind -= 1
        // FIXME: do I need to pass optopt to the err?
        //"option `%s%s' requires an argument"
        throw CmdErr(
          1, "option \(current_dash)\(current_key) requires an argument")

        /*        /*
                   * XXX: GNU sets optopt to val regardless of flag
                   */
         if (long_options[match].flag == NULL) {
         optopt = long_options[match].val
         }
         else {
         optopt = "\0"
         }
         */
        //        return (BADARG, "")
      }
    } else { /* unknown option */
      if short_too {
        optind -= 1
        return nil
      }
      // "unrecognized option `%s%s'"
      throw CmdErr(1, "unrecognized option \(current_dash)\(current_key)")
      //      optopt = "\0"
    }

    return (long_options[match].name, optarg)
  }

  // -=================================================================================================================

  /*
   * getopt_internal --
   *  Parse argc/argv argument vector.  Called by user level routines.
   */
  func getopt_internal(_ flagsx: GLFlags) throws(CmdErr) -> (String, String)? {
    //  char *oli;        /* option letter list index */
    //  int optchar, short_too;

    var optchar: String = "?"
    var short_too = false

    var flags = flagsx
    if options.first == "-" {
      flags.formUnion(.FLAG_ALLARGS)
    } else if posixly_correct || options.first == "+" {
      flags.remove(.FLAG_PERMUTE)
    }
    if options.first == "+" || options.first == "-" {
      options.removeFirst()
    }

    //  optarg = nil

    while true {
      // start:
      if place.isEmpty { /* update scanning pointer */
        if optind >= nargv.count { /* end of argument vector */
          place = ""
          if nonopt_end != -1 {
            /* do permutation, if we have to */
            permute_args(nonopt_start, nonopt_end, optind, &nargv)
            optind -= nonopt_end - nonopt_start
          } else if nonopt_start != -1 {
            /*
             * If we skipped non-options, set optind
             * to the first of them.
             */
            optind = nonopt_start
          }
          nonopt_start = -1
          nonopt_end = -1
          return nil
        }

        place = nargv[optind]
        if place.first != "-" || place.count == 1 {
          place = "" /* found non-option */
          if flags.contains(.FLAG_ALLARGS) {
            /*
             * GNU extension:
             * return non-option as argument to option 1
             */
            optarg = nargv[optind]
            optind += 1
            return (INORDER, optarg)
          }
          if !flags.contains(.FLAG_PERMUTE) {
            /*
             * If no permutation wanted, stop parsing
             * at first non-option.
             */
            return nil
          }
          /* do permutation */
          if nonopt_start == -1 {
            nonopt_start = optind
          } else if nonopt_end != -1 {
            permute_args(nonopt_start, nonopt_end, optind, &nargv)
            nonopt_start = optind - (nonopt_end - nonopt_start)
            nonopt_end = -1
          }
          optind += 1
          /* process next argument */
          continue

        }

        if nonopt_start != -1 && nonopt_end == -1 {
          nonopt_end = optind
        }

        /*
         * If we have "-" do nothing, if "--" we are done.
         */
        if place.count > 1 {
          place.removeFirst()
          if place == "-" {
            optind += 1
            place = ""

            /*
             * We found an option (--), so if we skipped
             * non-options, we have to permute.
             */
            if nonopt_end != -1 {
              permute_args(nonopt_start, nonopt_end, optind, &nargv)
              optind -= nonopt_end - nonopt_start
            }
            nonopt_start = -1
            nonopt_end = -1
            return nil
          }
        }
      }
      break
    }
    /*
     * Check long options if:
     *  1) we were passed some
     *  2) the arg is not just "-"
     *  3) either the arg starts with -- we are getopt_long_only()
     */
    if place != nargv[optind]
      && (place.first == "-" || flags.contains(.FLAG_LONGONLY))
    {
      short_too = false

      dash_prefix = D_PREFIX

      if place.first == "-" {
        place.removeFirst() /* --foo long option */
        if place.isEmpty {
          throw CmdErr(1, "malformed option")  //  BADARG  /* malformed option */
        }

        dash_prefix = DD_PREFIX

      } else if place.first != ":"
        && strchr(options, Int32(UnicodeScalar(place.first!.asciiValue!).value))
          != nil
      {
        short_too = true /* could be short option too */
      }

      if let k = try parse_long_options(short_too, flags) {
        place = ""
        return k
      }
    }

    let oc = place.removeFirst()
    var oli: Character?
    var oli2: Character?
    var oli3: Character?
    if let oo = options.firstIndex(of: oc) {
      let olix = options.suffix(from: oo)
      oli = olix.first
      oli2 = olix.dropFirst().first
      oli3 = olix.dropFirst(2).first
    }
    optchar = String(oc)

    if optchar == ":" || (optchar == "-" && !place.isEmpty) || oli == nil {
      /*
       * If the user specified "-" and  '-' isn't listed in
       * options, return -1 (non-option) as per POSIX.
       * Otherwise, it is an unknown option character (or ':').
       */
      if optchar == "-" && place.isEmpty {
        return nil
      }
      if place.isEmpty {
        optind += 1
      }
      // "illegal option -- %c"
      // "invalid option -- %c"
      throw CmdErr(
        1,
        posixly_correct
          ? "illegal option -- \(optchar)" : "invalid option -- \(optchar)")
      //      optopt = optchar;
    }
    if optchar == "W" && oli2 == ";" {
      /* -W long-option */
      if !place.isEmpty { /* no space */
        /* NOTHING */
      } else {
        optind += 1
        if optind >= nargv.count { /* no arg */
          place = ""
          // "option requires an argument -- %c"
          throw CmdErr(1, "option requires an argument -- \(optchar)")
          //          optopt = optchar;
        } else { /* white space */
          place = nargv[optind]
        }
      }

      dash_prefix = W_PREFIX

      return try parse_long_options(false, flags)
    }
    if oli2 != ":" { /* doesn't take argument */
      if place.isEmpty {
        optind += 1
      }
    } else { /* takes (optional) argument */
      optarg = ""
      if !place.isEmpty { /* no white space */
        optarg = place
      } else if oli3 != ":" { /* arg not optional */
        optind += 1
        if optind >= nargv.count { /* no arg */
          place = ""

          // FIXME: do I need to pass the optchar to the error?
          throw CmdErr(1, "option requires an argument -- \(optchar)")
          //          optopt = optchar
        } else {
          optarg = nargv[optind]
        }
      }
      place = ""
      optind += 1
    }
    /* dump back option letter */
    return (optchar, optarg)
  }

  /// Parse argc/argv argument vector.
  public func getopt_long() throws(CmdErr) -> (String, String)? {
    return try getopt_internal(GLFlags.FLAG_PERMUTE)
  }

  // getopt_long_only -- Parse argc/argv argument vector.
  public func getopt_long_only() throws(CmdErr) -> (String, String)? {

    return try getopt_internal(GLFlags.FLAG_PERMUTE.union(.FLAG_LONGONLY))
  }

  public var remaining: [String] {
    return Array(nargv.dropFirst(optind))
  }
}

/*
 #if 0
 #if defined(LIBC_SCCS) && !defined(lint)
 static char *rcsid = "$OpenBSD: getopt_long.c,v 1.16 2004/02/04 18:17:25 millert Exp $";
 #endif /* LIBC_SCCS and not lint */
 #endif
 #include <sys/cdefs.h>
 __FBSDID("$FreeBSD$");

 #include <err.h>
 #include <errno.h>
 #include <getopt.h>
 #include <stdlib.h>
 #include <string.h>

 #define GNU_COMPATIBLE    /* Be more compatible, configure's use us! */

 #if 0        /* we prefer to keep our getopt(3) */
 #define  REPLACE_GETOPT    /* use this getopt as the system getopt(3) */
 #endif

 #ifdef REPLACE_GETOPT
 int  opterr = 1;    /* if error message should be printed */
 int  optind = 1;    /* index into parent argv vector */
 int  optopt = '?';    /* character checked for validity */
 int  optreset;    /* reset getopt */
 char    *optarg;    /* argument associated with option */
 #endif

 #define PRINT_ERROR  ((opterr) && (*options != ':'))

 #define FLAG_PERMUTE  0x01  /* permute non-options to the end of argv */
 #define FLAG_ALLARGS  0x02  /* treat non-options as args to option "-1" */
 #define FLAG_LONGONLY  0x04  /* operate as getopt_long_only */

 /* return values */
 #define  BADCH    (int)'?'
 #define  BADARG    ((*options == ':') ? (int)':' : (int)'?')
 #define  INORDER   (int)1

 static char EMSG[] = "";

 #ifdef GNU_COMPATIBLE
 #define NO_PREFIX  (-1)
 #define D_PREFIX  0
 #define DD_PREFIX  1
 #define W_PREFIX  2
 #endif

 static int getopt_internal(int, char * const *, const char *,
          const struct option *, int *, int);
 static int parse_long_options(char * const *, const char *,
             const struct option *, int *, int, int);
 static int gcd(int, int);
 static void permute_args(int, int, int, char * const *);

 static char *place = EMSG; /* option letter processing */

 /* XXX: set optreset to 1 rather than these two */
 static int nonopt_start = -1; /* first non option argument (for permute) */
 static int nonopt_end = -1;   /* first option after non options (for permute) */

 /* Error messages */
 static const char recargchar[] = "option requires an argument -- %c";
 static const char illoptchar[] = "illegal option -- %c"; /* From P1003.2 */
 #ifdef GNU_COMPATIBLE
 static int dash_prefix = NO_PREFIX;
 static const char gnuoptchar[] = "invalid option -- %c";

 static const char recargstring[] = "option `%s%s' requires an argument";
 static const char ambig[] = "option `%s%.*s' is ambiguous";
 static const char noarg[] = "option `%s%.*s' doesn't allow an argument";
 static const char illoptstring[] = "unrecognized option `%s%s'";
 #else
 static const char recargstring[] = "option requires an argument -- %s";
 static const char ambig[] = "ambiguous option -- %.*s";
 static const char noarg[] = "option doesn't take an argument -- %.*s";
 static const char illoptstring[] = "unknown option -- %s";
 #endif

 /*
  * Compute the greatest common divisor of a and b.
  */
 static int
 gcd(int a, int b)
 {
   int c;

   c = a % b;
   while (c != 0) {
     a = b;
     b = c;
     c = a % b;
   }

   return (b);
 }

 /*
  * Exchange the block from nonopt_start to nonopt_end with the block
  * from nonopt_end to opt_end (keeping the same order of arguments
  * in each block).
  */
 static void
 permute_args(int panonopt_start, int panonopt_end, int opt_end,
   char * const *nargv)
 {
   int cstart, cyclelen, i, j, ncycle, nnonopts, nopts, pos;
   char *swap;

   /*
    * compute lengths of blocks and number and size of cycles
    */
   nnonopts = panonopt_end - panonopt_start;
   nopts = opt_end - panonopt_end;
   ncycle = gcd(nnonopts, nopts);
   cyclelen = (opt_end - panonopt_start) / ncycle;

   for (i = 0; i < ncycle; i++) {
     cstart = panonopt_end+i;
     pos = cstart;
     for (j = 0; j < cyclelen; j++) {
       if (pos >= panonopt_end)
         pos -= nnonopts;
       else
         pos += nopts;
       swap = nargv[pos];
       /* LINTED const cast */
       ((char **) nargv)[pos] = nargv[cstart];
       /* LINTED const cast */
       ((char **)nargv)[cstart] = swap;
     }
   }
 }

 /*
  * parse_long_options --
  *  Parse long options in argc/argv argument vector.
  * Returns -1 if short_too is set and the option does not match long_options.
  */
 static int
 parse_long_options(char * const *nargv, const char *options,
   const struct option *long_options, int *idx, int short_too, int flags)
 {
   char *current_argv, *has_equal;
 #ifdef GNU_COMPATIBLE
   const char *current_dash;
 #endif
   size_t current_argv_len;
   int i, match, exact_match, second_partial_match;

   current_argv = place;
 #ifdef GNU_COMPATIBLE
   switch (dash_prefix) {
     case D_PREFIX:
       current_dash = "-";
       break;
     case DD_PREFIX:
       current_dash = "--";
       break;
     case W_PREFIX:
       current_dash = "-W ";
       break;
     default:
       current_dash = "";
       break;
   }
 #endif
   match = -1;
   exact_match = 0;
   second_partial_match = 0;

   optind++;

   if ((has_equal = strchr(current_argv, '=')) != NULL) {
     /* argument found (--option=arg) */
     current_argv_len = has_equal - current_argv;
     has_equal++;
   } else
     current_argv_len = strlen(current_argv);

   for (i = 0; long_options[i].name; i++) {
     /* find matching long option */
     if (strncmp(current_argv, long_options[i].name,
         current_argv_len))
       continue;

     if (strlen(long_options[i].name) == current_argv_len) {
       /* exact match */
       match = i;
       exact_match = 1;
       break;
     }
     /*
      * If this is a known short option, don't allow
      * a partial match of a single character.
      */
     if (short_too && current_argv_len == 1)
       continue;

     if (match == -1)  /* first partial match */
       match = i;
     else if ((flags & FLAG_LONGONLY) ||
        long_options[i].has_arg !=
            long_options[match].has_arg ||
        long_options[i].flag != long_options[match].flag ||
        long_options[i].val != long_options[match].val)
       second_partial_match = 1;
   }
   if (!exact_match && second_partial_match) {
     /* ambiguous abbreviation */
     if (PRINT_ERROR)
       warnx(ambig,
 #ifdef GNU_COMPATIBLE
            current_dash,
 #endif
            (int)current_argv_len,
            current_argv);
     optopt = 0;
     return (BADCH);
   }
   if (match != -1) {    /* option found */
     if (long_options[match].has_arg == no_argument
         && has_equal) {
       if (PRINT_ERROR)
         warnx(noarg,
 #ifdef GNU_COMPATIBLE
              current_dash,
 #endif
              (int)current_argv_len,
              current_argv);
       /*
        * XXX: GNU sets optopt to val regardless of flag
        */
       if (long_options[match].flag == NULL)
         optopt = long_options[match].val;
       else
         optopt = 0;
 #ifdef GNU_COMPATIBLE
       return (BADCH);
 #else
       return (BADARG);
 #endif
     }
     if (long_options[match].has_arg == required_argument ||
         long_options[match].has_arg == optional_argument) {
       if (has_equal)
         optarg = has_equal;
       else if (long_options[match].has_arg ==
           required_argument) {
         /*
          * optional argument doesn't use next nargv
          */
         optarg = nargv[optind++];
       }
     }
     if ((long_options[match].has_arg == required_argument)
         && (optarg == NULL)) {
       /*
        * Missing argument; leading ':' indicates no error
        * should be generated.
        */
       if (PRINT_ERROR)
         warnx(recargstring,
 #ifdef GNU_COMPATIBLE
             current_dash,
 #endif
             current_argv);
       /*
        * XXX: GNU sets optopt to val regardless of flag
        */
       if (long_options[match].flag == NULL)
         optopt = long_options[match].val;
       else
         optopt = 0;
       --optind;
       return (BADARG);
     }
   } else {      /* unknown option */
     if (short_too) {
       --optind;
       return (-1);
     }
     if (PRINT_ERROR)
       warnx(illoptstring,
 #ifdef GNU_COMPATIBLE
             current_dash,
 #endif
             current_argv);
     optopt = 0;
     return (BADCH);
   }
   if (idx)
     *idx = match;
   if (long_options[match].flag) {
     *long_options[match].flag = long_options[match].val;
     return (0);
   } else
     return (long_options[match].val);
 }

 /*
  * getopt_internal --
  *  Parse argc/argv argument vector.  Called by user level routines.
  */
 static int
 getopt_internal(int nargc, char * const *nargv, const char *options,
   const struct option *long_options, int *idx, int flags)
 {
   char *oli;        /* option letter list index */
   int optchar, short_too;
   static int posixly_correct = -1;

   if (options == NULL)
     return (-1);

   /*
    * XXX Some GNU programs (like cvs) set optind to 0 instead of
    * XXX using optreset.  Work around this braindamage.
    */
   if (optind == 0)
     optind = optreset = 1;

   /*
    * Disable GNU extensions if POSIXLY_CORRECT is set or options
    * string begins with a '+'.
    */
   if (posixly_correct == -1 || optreset)
     posixly_correct = (getenv("POSIXLY_CORRECT") != NULL);
   if (*options == '-')
     flags |= FLAG_ALLARGS;
   else if (posixly_correct || *options == '+')
     flags &= ~FLAG_PERMUTE;
   if (*options == '+' || *options == '-')
     options++;

   optarg = NULL;
   if (optreset)
     nonopt_start = nonopt_end = -1;
 start:
   if (optreset || !*place) {    /* update scanning pointer */
     optreset = 0;
     if (optind >= nargc) {          /* end of argument vector */
       place = EMSG;
       if (nonopt_end != -1) {
         /* do permutation, if we have to */
         permute_args(nonopt_start, nonopt_end,
             optind, nargv);
         optind -= nonopt_end - nonopt_start;
       }
       else if (nonopt_start != -1) {
         /*
          * If we skipped non-options, set optind
          * to the first of them.
          */
         optind = nonopt_start;
       }
       nonopt_start = nonopt_end = -1;
       return (-1);
     }
     if (*(place = nargv[optind]) != '-' ||
 #ifdef GNU_COMPATIBLE
         place[1] == '\0') {
 #else
         (place[1] == '\0' && strchr(options, '-') == NULL)) {
 #endif
       place = EMSG;    /* found non-option */
       if (flags & FLAG_ALLARGS) {
         /*
          * GNU extension:
          * return non-option as argument to option 1
          */
         optarg = nargv[optind++];
         return (INORDER);
       }
       if (!(flags & FLAG_PERMUTE)) {
         /*
          * If no permutation wanted, stop parsing
          * at first non-option.
          */
         return (-1);
       }
       /* do permutation */
       if (nonopt_start == -1)
         nonopt_start = optind;
       else if (nonopt_end != -1) {
         permute_args(nonopt_start, nonopt_end,
             optind, nargv);
         nonopt_start = optind -
             (nonopt_end - nonopt_start);
         nonopt_end = -1;
       }
       optind++;
       /* process next argument */
       goto start;
     }
     if (nonopt_start != -1 && nonopt_end == -1)
       nonopt_end = optind;

     /*
      * If we have "-" do nothing, if "--" we are done.
      */
     if (place[1] != '\0' && *++place == '-' && place[1] == '\0') {
       optind++;
       place = EMSG;
       /*
        * We found an option (--), so if we skipped
        * non-options, we have to permute.
        */
       if (nonopt_end != -1) {
         permute_args(nonopt_start, nonopt_end,
             optind, nargv);
         optind -= nonopt_end - nonopt_start;
       }
       nonopt_start = nonopt_end = -1;
       return (-1);
     }
   }

   /*
    * Check long options if:
    *  1) we were passed some
    *  2) the arg is not just "-"
    *  3) either the arg starts with -- we are getopt_long_only()
    */
   if (long_options != NULL && place != nargv[optind] &&
       (*place == '-' || (flags & FLAG_LONGONLY))) {
     short_too = 0;
 #ifdef GNU_COMPATIBLE
     dash_prefix = D_PREFIX;
 #endif
     if (*place == '-') {
       place++;    /* --foo long option */
       if (*place == '\0')
         return (BADARG);  /* malformed option */
 #ifdef GNU_COMPATIBLE
       dash_prefix = DD_PREFIX;
 #endif
     } else if (*place != ':' && strchr(options, *place) != NULL)
       short_too = 1;    /* could be short option too */

     optchar = parse_long_options(nargv, options, long_options,
         idx, short_too, flags);
     if (optchar != -1) {
       place = EMSG;
       return (optchar);
     }
   }

   if ((optchar = (int)*place++) == (int)':' ||
       (optchar == (int)'-' && *place != '\0') ||
       (oli = strchr(options, optchar)) == NULL) {
     /*
      * If the user specified "-" and  '-' isn't listed in
      * options, return -1 (non-option) as per POSIX.
      * Otherwise, it is an unknown option character (or ':').
      */
     if (optchar == (int)'-' && *place == '\0')
       return (-1);
     if (!*place)
       ++optind;
 #ifdef GNU_COMPATIBLE
     if (PRINT_ERROR)
       warnx(posixly_correct ? illoptchar : gnuoptchar,
             optchar);
 #else
     if (PRINT_ERROR)
       warnx(illoptchar, optchar);
 #endif
     optopt = optchar;
     return (BADCH);
   }
   if (long_options != NULL && optchar == 'W' && oli[1] == ';') {
     /* -W long-option */
     if (*place)      /* no space */
       /* NOTHING */;
     else if (++optind >= nargc) {  /* no arg */
       place = EMSG;
       if (PRINT_ERROR)
         warnx(recargchar, optchar);
       optopt = optchar;
       return (BADARG);
     } else        /* white space */
       place = nargv[optind];
 #ifdef GNU_COMPATIBLE
     dash_prefix = W_PREFIX;
 #endif
     optchar = parse_long_options(nargv, options, long_options,
         idx, 0, flags);
     place = EMSG;
     return (optchar);
   }
   if (*++oli != ':') {      /* doesn't take argument */
     if (!*place)
       ++optind;
   } else {        /* takes (optional) argument */
     optarg = NULL;
     if (*place)      /* no white space */
       optarg = place;
     else if (oli[1] != ':') {  /* arg not optional */
       if (++optind >= nargc) {  /* no arg */
         place = EMSG;
         if (PRINT_ERROR)
           warnx(recargchar, optchar);
         optopt = optchar;
         return (BADARG);
       } else
         optarg = nargv[optind];
     }
     place = EMSG;
     ++optind;
   }
   /* dump back option letter */
   return (optchar);
 }

 #ifdef REPLACE_GETOPT
 /*
  * getopt --
  *  Parse argc/argv argument vector.
  *
  * [eventually this will replace the BSD getopt]
  */
 int
 getopt(int nargc, char * const *nargv, const char *options)
 {

   /*
    * We don't pass FLAG_PERMUTE to getopt_internal() since
    * the BSD getopt(3) (unlike GNU) has never done this.
    *
    * Furthermore, since many privileged programs call getopt()
    * before dropping privileges it makes sense to keep things
    * as simple (and bug-free) as possible.
    */
   return (getopt_internal(nargc, nargv, options, NULL, NULL, 0));
 }
 #endif /* REPLACE_GETOPT */

 /*
  * getopt_long --
  *  Parse argc/argv argument vector.
  */
 int
 getopt_long(int nargc, char * const *nargv, const char *options,
   const struct option *long_options, int *idx)
 {

   return (getopt_internal(nargc, nargv, options, long_options, idx,
       FLAG_PERMUTE));
 }

 /*
  * getopt_long_only --
  *  Parse argc/argv argument vector.
  */
 int
 getopt_long_only(int nargc, char * const *nargv, const char *options,
   const struct option *long_options, int *idx)
 {

   return (getopt_internal(nargc, nargv, options, long_options, idx,
       FLAG_PERMUTE|FLAG_LONGONLY));
 }
 */

// =========================================================================
// =========================================================================

// ==========================================

// in order to deal with the "Reference to var 'optarg' is not concurrency-safe because it involves shared mutable state"
// problem, I need to port getopt.c to Swift instead of using libc

/*    $NetBSD: getopt.c,v 1.29 2014/06/05 22:00:22 christos Exp $    */

/*-
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * Copyright (c) 1987, 1993, 1994
 *    The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 int    opterr = 1,        /* if error message should be printed */
 optind = 1,        /* index into parent argv vector */
 optopt,            /* character checked for validity */
 optreset;        /* reset getopt */
 char    *optarg;        /* argument associated with option */

 #define    BADCH    (int)'?'
 #define    BADARG    (int)':'
 static char EMSG[] = "";

 #if __DARWIN_UNIX03
 #define PROGNAME nargv[0]
 #else
 #define PROGNAME _getprogname()
 #endif

 /*
  * getopt --
  *    Parse argc/argv argument vector.
  */
 int
 getopt(int nargc, char * const nargv[], const char *ostr)
 {
 static char *place = EMSG;        /* option letter processing */
 char *oli;                /* option letter list index */

 if (optreset || *place == 0) {        /* update scanning pointer */
 optreset = 0;
 place = nargv[optind];
 if (optind >= nargc || *place++ != '-') {
 /* Argument is absent or is not an option */
 place = EMSG;
 return (-1);
 }
 optopt = *place++;
 if (optopt == '-' && *place == 0) {
 /* "--" => end of options */
 ++optind;
 place = EMSG;
 return (-1);
 }
 if (optopt == 0) {
 /* Solitary '-', treat as a '-' option
  if the program (eg su) is looking for it. */
 place = EMSG;
 if (strchr(ostr, '-') == NULL)
 return (-1);
 optopt = '-';
 }
 } else
 optopt = *place++;

 /* See if option letter is one the caller wanted... */
 if (optopt == ':' || (oli = strchr(ostr, optopt)) == NULL) {
 if (*place == 0)
 ++optind;
 if (opterr && *ostr != ':')
 (void)fprintf(stderr,
 "%s: illegal option -- %c\n",
 PROGNAME, optopt);
 return (BADCH);
 }

 /* Does this option need an argument? */
 if (oli[1] != ':') {
 /* don't need argument */
 optarg = NULL;
 if (*place == 0)
 ++optind;
 } else {
 /* Option-argument is either the rest of this argument or the
  entire next argument. */
 if (*place)
 optarg = place;
 else if (oli[2] == ':')
 /*
  * GNU Extension, for optional arguments if the rest of
  * the argument is empty, we return NULL
  */
 optarg = NULL;
 else if (nargc > ++optind)
 optarg = nargv[optind];
 else {
 /* option-argument absent */
 #if __DARWIN_UNIX03
 /* Yes, the standard will put optind past the last
  argument */
 ++optind;
 optarg = NULL;
 #endif /* __DARWIN_UNIX03 */
 place = EMSG;
 if (*ostr == ':')
 return (BADARG);
 if (opterr)
 (void)fprintf(stderr,
 "%s: option requires an argument -- %c\n",
 PROGNAME, optopt);
 return (BADCH);
 }
 place = EMSG;
 ++optind;
 }
 return (optopt);            /* return option letter */
 }
 */

public class BSDGetopt {
  var optarg: String = ""  // argument associated with option

  var ostr: String
  var nargv: ArraySlice<String>
  var place = ""

  let PROGNAME = CommandLine.arguments[0]

  /// parse the command line options using the option definition string `ostr`.  Optionally, pass in the array of strings to be used as the argument array -- otherwise the default `CommandLine.arguments` will be used
  public init(
    _ ostr: String, args: ArraySlice<String> = CommandLine.arguments.dropFirst()
  ) {
    self.ostr = ostr
    self.nargv = args
  }

  /// return the arguments remaining after the options processing has completed
  public var remaining: [String] { Array(nargv) }

  /// consume the next argument (assuming it has been processed elsewhere)
  public func skip(_ n: Int = 1) {
    nargv = nargv.dropFirst(n)
  }

  /// Parse the next option -- returning the option character and the option argument (or nil if the next token is not an option)
  public func getopt() throws(CmdErr) -> (Character, String)? {
    var optopt: Character = "?"  // character checked for validity
    guard nargv.count > 0 else {
      return nil
    }

    if place.isEmpty {
      place = nargv.first!

      guard !place.isEmpty, place.removeFirst() == "-" else {
        // Argument is absent or is not an option
        place = ""
        return nil
      }

      //    nargv.removeFirst()  // consume this token
      if place == "-" {
        nargv.removeFirst()
        place = ""
        // "--" => end of options
        return nil
      }

      if place.isEmpty {
        // Solitary '-', treat as a '-' option if the program (eg su) is looking for it.
        if ostr.contains("-") {
          optopt = "-"
        } else {
          return nil
        }
      } else {
        optopt = place.removeFirst()
      }
    } else {
      optopt = place.removeFirst()
    }

    // See if option letter is one the caller wanted...
    if optopt == ":" || !ostr.contains(optopt) {
      if place.isEmpty {
        nargv.removeFirst()
      }
      //   place = nargv.count == 0 ? "" : nargv.removeFirst()
      // }
      if ostr.first != ":" {
        throw CmdErr(1, "\(PROGNAME): illegal option -- \(optopt))")
      }
    }

    // Does this option need an argument?
    if ostr.range(of: "\(optopt):") == nil {
      // don't need argument
      optarg = ""
      if place.isEmpty { nargv.removeFirst() }
    } else {
      // Option-argument is either the rest of this argument or the entire next argument.
      if !place.isEmpty {
        optarg = place
      } else if ostr.contains("\(optopt)::") {
        // GNU Extension, for optional arguments if the rest of the argument is empty, we return ""
        optarg = ""
      } else if nargv.count > 1 {
        nargv.removeFirst()
        optarg = nargv.first!
      } else {
        // option-argument absent
        if !nargv.isEmpty { nargv.removeFirst() }
        optarg = ""
        place = ""
        if ostr.first == ":" {
          return (":", "")
        }
        throw CmdErr(1, "\(PROGNAME): option requires an argument \(optopt)")
      }
      place = ""
      if !nargv.isEmpty { nargv.removeFirst() }
    }
    return (optopt, optarg)  // return option letter and argument
  }
}

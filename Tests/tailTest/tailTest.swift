
// Generated by Robert "r0ml" Lefkowitz <code@liberally.net> in 2024
// from a file containing the following notice:

/*
  Copyright (c) 2016 Alan Somers
 
  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in the
     documentation and/or other materials provided with the distribution.
 
  THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
  OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
  OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  SUCH DAMAGE.
 */

import ShellTesting

@Suite(.serialized) class tailTest : ShellTest {
  let cmd = "tail"
  let suiteBundle = "tailTest"

  let ex = "tail"

  @Test("Reverse an empty file") func empty_r() async throws {
    let i = try tmpfile("inFile", Data() )
    defer { rm(i) }
    try await run(output: "", args: "-r", i)
  }
  
  @Test("Reverse a file") func file_r() async throws {
    let d = """
This is the first line
This is the second line
This is the third line

"""
    let i = try tmpfile("inFile", d)
    defer { rm(i) }
    let op = d.split(separator: "\n").reversed().joined(separator: "\n").appending("\n")
    try await run(output: op, args: "-r", i)
  }
  
  @Test("Reverse the last two lines of a file") func file_rn2() async throws {
    let d = """
This is the first line
This is the second line
This is the third line

"""
    let i = try tmpfile("inFile", d)
    let o = """
This is the third line
This is the second line

"""
    defer { rm(i) }
    try await run(output: o, args: "-rn2", i)
  }
  
  @Test("Reverse a pipe whose first character is a newline") func pipe_leading_newline_r() async throws {
    let d = """

This is the first line
This is the second line
This is the third line

"""
    let i = try tmpfile("inFile", d)
    let o = """
This is the third line
This is the second line
This is the first line


"""
    defer { rm(i) }
    try await run(output: o, args: "-r", i)
    try await run(withStdin: d, output: o, args: "-r")
  }
  
  @Test("Reverse a file and display the last 28 characters") func file_rc28() async throws {
    let d = """
This is the first line
This is the second line
This is the third line

"""
    let i = try tmpfile("inFile", d)
    let o = """
This is the third line
line

"""
    defer { rm(i) }

    try await run(output: o, args: "-rc28", i)
  }

  @Test("Reverse stdin and display the last 28 characters") func stdin_rc28() async throws {
    let d = """
This is the first line
This is the second line
This is the third line

"""
    let o = """
This is the third line
line

"""
    try await run(withStdin: d, output: o, args: "-rc28")
  }
  
  @Test("Reverse a long file") func longfile_r() async throws {
    let k = NumberFormatter()
    k.paddingCharacter = "0"
    k.formatWidth = 511
    let p = 0..<1030
    let d = (p.map { (k.string(from: NSNumber(value: $0) ))!+"\n" }).joined()
    let i = try tmpfile("inFile", d)

    let q = stride(from: 1029, through: 0, by: -1)
    let o = (q.map { (k.string(from: NSNumber(value: $0) ))!+"\n" }).joined()
    
    defer { rm(i) }
    let p2 = ShellProcess(ex, "-r", i)
    
    // FIXME: how come it doesn't work if I pipe output to stdout
    let of = try tmpfile("outfile", Data())
    let ofh = try FileHandle(forWritingTo: of)
    await p2.setOutput(ofh)
    let _ = try await p2.run()
    let j = try String(contentsOf: of, encoding: .utf8)
    let bb = j == o
    #expect( j.count == o.count)
    #expect( bb )
    
    let of2 = try tmpfile("outpipe", Data())
    let ofh2 = try FileHandle(forWritingTo: of2)
    let p3 = ShellProcess(ex, "-r")
    await p3.setOutput(ofh2)
    let _ = try await p3.run(d)
    let j2 = try String(contentsOf: of2, encoding: .utf8)
    let bb2 = j2 == o
    #expect( bb2 )
    
    [of, of2, i].forEach { rm($0) }
  }
  
  @Test("Reverse a file that's too long to store in RAM", .disabled("with virtual memory and inability to set ulimit, this doesn't test anything")) func longfile_r_enomem() async throws {
    /* When we reverse a file that's too long for RAM, tail should drop the
     first part and just print what it can.  We'll check that the last
     part is ok
     */
    
    let k = NumberFormatter()
    k.paddingCharacter = "0"
    k.formatWidth = 1023
    let p = 0..<32768
    let d = (p.map { (k.string(from: NSNumber(value: $0) ))!+"\n" }).joined()
    
    let q = stride(from: 32767, through: 0, by: -1)
    let o = (q.map { (k.string(from: NSNumber(value: $0) ))!+"\n" }).joined()
    
    try await run(withStdin: d, output: o, args: "-r")
  }
  
  @Test("Reverse a long file with extremely long lines") func longfile_r_longlines() async throws {
    let k = NumberFormatter()
    k.paddingCharacter = "0"
    k.formatWidth = 7
    let lines : [String] = [
      ((0 ..< 18000).map { k.string(from: NSNumber(value: $0))! }).joined(separator: " ")+"\n",
      ((18000 ..< 36000).map { k.string(from: NSNumber(value: $0))! }).joined(separator: " ")+"\n",
      ((36000 ..< 54000).map { k.string(from: NSNumber(value: $0))! }).joined(separator: " ")+"\n",
    ]
    
    // FIXME: why didn't this work with pipe?
    let p = ShellProcess(ex, "-r")
    let of = try tmpfile("outfile", "")
    let ofh = try FileHandle(forWritingTo: of)
    await p.setOutput(ofh)
    let po = try await p.run( lines.joined() )
    #expect(po.code == 0)
    let j = try String(contentsOf: of, encoding: .utf8)
    #expect( j == lines.reversed().joined() )
  }

  @Test("Reverse a long file and print the last 135782 bytes") func longfile_rc135782() async throws {
    let k = NumberFormatter()
    k.paddingCharacter = "0"
    k.formatWidth = 63
    let i = ((0 ..< 9000).map { k.string(from: NSNumber(value: $0))!+"\n" }).joined()
    /*
     let inf = FileManager.default.temporaryDirectory.appendingPathComponent("inFile")
     try i.write(to: inf, atomically: true, encoding: .utf8)
     */

    // FIXME: doesnt work with pipe output -- would work with file
    let o = ((stride(from: 8999, to: 0, by: -1).prefix(2121)).map { k.string(from: NSNumber(value: $0))!+"\n"}).joined() + "0000000000000000000000000000000006878\n"
    try await run(withStdin: i, output: o, args: "-rc135782")
  }
  
  @Test("Reverse a long file with extremely long lines and print the last 145,782 bytes") func longfile_rc145782_longlines() async throws {
    let k = NumberFormatter()
    k.paddingCharacter = "0"
    k.formatWidth = 7

/*    let lines : [String] = [
      ((0 ..< 18000).map { k.string(from: NSNumber(value: $0))! }).joined(separator: " ")+"\n",
      ((18000 ..< 36000).map { k.string(from: NSNumber(value: $0))! }).joined(separator: " ")+"\n",
      ((36000 ..< 54000).map { k.string(from: NSNumber(value: $0))! }).joined(separator: " ")+"\n",
    ]
  */
    
    let lines : [String] = [
      ((0..<18000).map { String(format: "%07d", $0)} ).joined(separator: " ")+"\n",
      ((18000..<36000).map { String(format: "%07d", $0)}).joined(separator: " ")+"\n",
        ((36000..<54000).map { String(format: "%07d", $0)}).joined(separator: " ") + "\n",
    ]
    
    let ro = ((35778..<(35778+222)).map { String(format: "%07d", $0) }).joined(separator: " ")
    //    let ro = ((35778..<(35778+222)).map { k.string(from: NSNumber(value: $0) )!}).joined(separator: " ")+"\n"

    let o = lines[2] + "35777 " + ro + "\n"

    try await run(withStdin: lines.joined(), output: o, args: "-rc145782")
  }

  @Test("Reverse a long file and print the last 2,500 lines") func longfile_rn2500() async throws {
    let k = NumberFormatter()
    k.paddingCharacter = "0"
    k.formatWidth = 63
    let i = ((0 ..< 9000).map { k.string(from: NSNumber(value: $0))!+"\n" }).joined()
    
    // FIXME: why didn't this work with pipe
    let p = ShellProcess(ex, "-rn2500")
    let of = try tmpfile("outfile", "")
    let ofh = try FileHandle(forWritingTo: of)
    await p.setOutput(ofh)
    let po = try await p.run(i)
    let j = try String(contentsOf: of, encoding: .utf8)
    
    #expect(po.code == 0)
    let o = ((stride(from: 8999, to: 0, by: -1).prefix(2500)).map { k.string(from: NSNumber(value: $0))!+"\n"}).joined()
    print(j.count, o.count)
    #expect( j == o )
  }
  
  @Test("Do not print bogus errno based output on short writes", .disabled("not implemented")) func broken_pipe() async throws {
    // Not yet implemented
    #expect(false)
  }
  
  @Test("Check basic operations on standard input", .disabled("all the operations use standard input")) func stdin() async throws {
    // Not yet implemented
    #expect(false)
  }
  
  @Test("Basic regression test for -f") func follow() async throws {
    let inf = try tmpfile("inFile",  "1\n2\n3\n")
    let inh = try FileHandle(forWritingTo: inf)

    let p = ShellProcess(ex, "-F", inf)
    try await p.theLaunch()

    try await Task.sleep(nanoseconds: UInt64(Double(NSEC_PER_SEC) * 0.1))
    let m = await p.midCapture()
    let k = String(data: m, encoding: .utf8)!
    try inh.seekToEnd()
    try inh.write(contentsOf: "4\n5\n".data(using:.utf8)! )

    try await Task.sleep(nanoseconds: UInt64(Double(NSEC_PER_SEC) * 0.2))
    #expect(k == "1\n2\n3\n")
    if let k2 = String(data: await p.midCapture(), encoding: .utf8) {
      #expect(k2 == "4\n5\n")
    } else {
      #expect(false)
    }
    await p.interrupt()
    rm(inf)
  }
  
  @Test("Verify that -f works with files piped to standard input") func follow_stdin() async throws {
    let p = ShellProcess(ex, "-f")

    let inf = try tmpfile("inFile", "1\n2\n3\n")

    Task.detached {
      let fh = try FileHandle(forReadingFrom: inf)
      try await p.run(fh)
      
      
//        AsyncDataActor([ "1\n2\n3\n".data(using: .utf8)!, "4\n5\n".data(using: .utf8)!]).stream)
    }

    try await Task.sleep(nanoseconds: UInt64(Double(NSEC_PER_SEC) * 0.1))
    let m = await p.midCapture()
    let k = String(data: m, encoding: .utf8)!
    
    let fh2 = try FileHandle(forWritingTo: inf)
    try fh2.seekToEnd()
    try fh2.write(contentsOf: "4\n5\n".data(using: .utf8)!)
    
    try await Task.sleep(nanoseconds: UInt64(Double(NSEC_PER_SEC) * 0.1))
    let m2 = await p.midCapture()
    let k2 = String(data: m2, encoding: .utf8)!

    #expect(k == "1\n2\n3\n")
    #expect(k2 == "4\n5\n")
    await p.interrupt()
    
    rm(inf)

  }

  @Test("Verify that -F works when a file is created") func follow_create() async throws {

    let inf = try tmpfile("inFile", Data())
    rm(inf)
    
    let p = ShellProcess(ex, "-F", inf)

    Task.detached {
       try await p.run()
    }

    try await Task.sleep(nanoseconds: UInt64(Double(NSEC_PER_SEC) * 1))

    try "1\n2\n3\n4\n5\n".write(to: inf, atomically: true, encoding: .utf8)

    try await Task.sleep(nanoseconds: UInt64(Double(NSEC_PER_SEC) * 1))
    let m = await p.midCapture()
    let k = String(data: m, encoding: .utf8)!
    
    #expect(k == "1\n2\n3\n4\n5\n")
    await p.interrupt()
  }

  @Test("Verify that -F works when a file is replaced") func follow_rename() async throws {

    let inf = try tmpfile("inFile", "1\n2\n3\n")
    let p = ShellProcess(ex, "-F", inf)

    Task.detached {
       try await p.run()
    }

    try await Task.sleep(nanoseconds: UInt64(Double(NSEC_PER_SEC) * 1))

    let inf2 = try tmpfile("infile_new", "4\n5\n")
    let inf3 = try tmpfile("infile_old", Data())
    rm(inf3)
    try FileManager.default.moveItem(at: inf, to: inf3)
    try FileManager.default.moveItem(at: inf2, to: inf)
    
    try await Task.sleep(nanoseconds: UInt64(Double(NSEC_PER_SEC) * 1))

    let m = await p.midCapture()
    let k = String(data: m, encoding: .utf8)!
    
    #expect(k == "1\n2\n3\n4\n5\n")
    await p.interrupt()
    
    [inf, inf2, inf3].forEach { rm($0) }

  }

  @Test("Test tail(1)'s silent header feature") func silent_header() async throws {
    
    let f1 = ((1...11).map { String($0)+"\n" }).joined()
    let inf = try tmpfile("file1", f1)
    defer { rm(inf) }
    let f2 = ((2...12).map { String($0)+"\n" }).joined()
    let inf2 = try tmpfile("file2", f2)
    defer { rm(inf2) }
    
    let o = String(f1.dropFirst(2)+f2.dropFirst(2))

    try await run(output: o, args: "-q", inf, inf2)
  }

  @Test("Test tail(1)'s verbose header feature") func verbose_header() async throws {
    
    let f1 = ((1...11).map { String($0)+"\n" }).joined()
    let inf = try tmpfile("file1", f1)
    defer { rm(inf) }
    let o = "==> \(inf.relativePath) <==\n"+f1.dropFirst(2)
    try await run(output: o, args: "-v", inf)
  }

  @Test("Test tail(1)'s SI number feature") func si_number() async throws {


    let f1 = Array(repeating: "aaaaaaa\n", count: 129).joined()
    let inf = try tmpfile("file1", f1)
    defer { rm(inf) }
    let o = Array(repeating: "aaaaaaa\n", count: 128).joined()
    try await run(output: o, args: "-c", "1k", inf)

    let f2 = ((1...1025).map { String($0)+"\n" }).joined()
    try f2.write(to: inf, atomically: true, encoding: .utf8)

    let o2 = ((2...1025).map { String($0)+"\n" }).joined()
    try await run(output: o2, args: "-n", "1k", inf)
  }

  @Test("File does not end in newline", arguments:
          [1,2,3,4]) func no_lf_at_eof(_ n : Int) async throws {

    let f1 = "a\nb\nc"
    let inf = try tmpfile("inFile", f1)
    defer { rm(inf) }
    let o = f1.split(separator: "\n", omittingEmptySubsequences: false)
    try await run(output: o.dropFirst(max(3-n, 0)).joined(separator: "\n"), args: "-\(n)", inf)
  }
  
  // ====================================================
  
  @Test("rdar://problem/96169775 - verify that the BOF is handled properly") func blkbof() async throws {
    
    let f1 = "first line\nsecond line\n"
    let inf = try tmpfile("blkbof.in", f1)
    defer { rm(inf) }
    var buf : stat = stat()
    let s = stat(inf.path, &buf)
    
    let blksiz = buf.st_blksize
    let cursize = buf.st_size
        
    let sizeleft = Int(blksiz) - Int(cursize) - 1
    let f2 = String(repeating: "1", count: sizeleft) + "\n"
    
    let infh = try FileHandle(forWritingTo: inf)
    infh.seekToEndOfFile()
    infh.write( f2.data(using: .utf8)!)
    
    try await run(output: f1 + f2, args: "-n", "3", inf)
/*    let p = ShellProcess(ex, "-n", "3", inf)
    let po = try await p.run()
    #expect(po.code == 0)
    #expect(po.string == f1 + f2)
*/

  }

  @Test("Regression test for radr://13271328") func radr_13271328() async throws {
    
    let inf = try tmpfile("blkbof.in", "")
    defer { rm(inf) }
    var buf : stat = stat()
    let _ = stat(inf.path, &buf)
    let blksiz = buf.st_blksize
//    let cursize = buf.st_size

    let linelen = Int(blksiz) * 3 / 2
    

    let f2 = String(repeating: "a", count: linelen) + "\n" +
    String(repeating: "b", count: linelen) + "\n"
    
    let infh = try FileHandle(forWritingTo: inf)
    try infh.seekToEnd()
    infh.write( f2.data(using: .utf8)!)
    
    let p = ShellProcess(ex, "-1", inf)
    let po = try await p.run()
    #expect(po.code == 0)
    #expect( (po.string.count { $0 == "\n"}) == 1)

  }


  
}

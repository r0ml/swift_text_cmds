
// Generated by Robert "r0ml" Lefkowitz <code@liberally.net> in 2024
// from a file containing the following notice:

/*
  Copyright (c) 2016 Alan Somers
 
  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in the
     documentation and/or other materials provided with the distribution.
 
  THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
  OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
  OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  SUCH DAMAGE.
 */
import Testing
import TestSupport
import Foundation

@Suite(.serialized) class tailTest {

  let ex = "tail"
  
  @Test("Reverse an empty file") func empty_r() async throws {
    let i = try tmpfile("try inFile", Data() )
    defer { rm(i) }
    let p = ShellProcess(ex, "-r", i.relativePath)
    let (_, j, _) = try await p.run()
    #expect( j!.isEmpty )
  }
  
  @Test("Reverse a file") func file_r() async throws {
    let d = """
This is the first line
This is the second line
This is the third line

"""
    let i = try tmpfile("try inFile", d)
    defer { rm(i) }
    let p = ShellProcess(ex, "-r", i.relativePath)
    let (_, j, _) = try await p.run()
    #expect( j == d.split(separator: "\n").reversed().joined(separator: "\n").appending("\n") )
    
  }
  
  @Test("Reverse the last two lines of a file") func file_rn2() async throws {
    let d = """
This is the first line
This is the second line
This is the third line

"""
    let i = try tmpfile("try inFile", d)
    let o = """
This is the third line
This is the second line

"""
    defer { rm(i) }
    let p = ShellProcess(ex, "-rn2", i.relativePath)
    let (_, j, _) = try await p.run()
    #expect( j == o )
  }
  
  @Test("Reverse a pipe whose first character is a newline") func pipe_leading_newline_r() async throws {
    let d = """

This is the first line
This is the second line
This is the third line

"""
    let i = try tmpfile("try inFile", d)
    let o = """
This is the third line
This is the second line
This is the first line


"""
    defer { rm(i) }
    let p = ShellProcess(ex, "-r", i.relativePath)
    let (_, j, _) = try await p.run()
    #expect( j == o )
    
    let p2 = ShellProcess(ex, "-r")
    let (_, j2, _) = try await p2.run(d)
    #expect( j2 == o )
  }
  
  @Test("Reverse a file and display the last 28 characters") func file_rc28() async throws {
    let d = """
This is the first line
This is the second line
This is the third line

"""
    let i = try tmpfile("try inFile", d)
    let o = """
This is the third line
line

"""
    defer { rm(i) }

    let p = ShellProcess(ex, "-rc28", i.relativePath)
    let (_, j, _) = try await p.run()
    #expect( j == o )
    
    let p2 = ShellProcess(ex, "-rc28")
    let (_, j2, _) = try await p2.run(d)
    #expect( j2 == o )
    
  }
  
  @Test("Reverse a long file") func longfile_r() async throws {
    let k = NumberFormatter()
    k.paddingCharacter = "0"
    k.formatWidth = 511
    let p = 0..<1030
    let d = (p.map { (k.string(from: NSNumber(value: $0) ))!+"\n" }).joined()
    let i = try tmpfile("try inFile", d)

    let q = stride(from: 1029, through: 0, by: -1)
    let o = (q.map { (k.string(from: NSNumber(value: $0) ))!+"\n" }).joined()
    
    defer { rm(i) }
    let p2 = ShellProcess(ex, "-r", i.relativePath)
    
    // FIXME: how come it doesn't work if I pipe output to stdout
    let of = try tmpfile("outfile", Data())
    let ofh = try FileHandle(forWritingTo: of)
    await p2.setOutput(ofh)
    let (_, _, _) = try await p2.run()
    let j = try String(contentsOf: of, encoding: .utf8)
    let bb = j == o
    #expect( j.count == o.count)
    #expect( bb )
    
    let of2 = try tmpfile("outpipe", Data())
    let ofh2 = try FileHandle(forWritingTo: of2)
    let p3 = ShellProcess(ex, "-r")
    await p3.setOutput(ofh2)
    let (_, _, _) = try await p3.run(d)
    let j2 = try String(contentsOf: of2, encoding: .utf8)
    let bb2 = j2 == o
    #expect( bb2 )
    
    [of, of2, i].forEach { rm($0) }
  }
  
  @Test("Reverse a file that's too long to store in RAM", .disabled("with virtual memory and inability to set ulimit, this doesn't test anything")) func longfile_r_enomem() async throws {
    /* When we reverse a file that's too long for RAM, tail should drop the
     first part and just print what it can.  We'll check that the last
     part is ok
     */
    
    let k = NumberFormatter()
    k.paddingCharacter = "0"
    k.formatWidth = 1023
    let p = 0..<32768
    let d = (p.map { (k.string(from: NSNumber(value: $0) ))!+"\n" }).joined()
    
    let q = stride(from: 32767, through: 0, by: -1)
    let o = (q.map { (k.string(from: NSNumber(value: $0) ))!+"\n" }).joined()
    
    let p4 = ShellProcess(ex, "-r")
    let (r, j, _) = try await p4.run(d)
    #expect(r == 0)
    #expect( j == o )
  }
  
  @Test("Reverse a long file with extremely long lines") func longfile_r_longlines() async throws {
    let k = NumberFormatter()
    k.paddingCharacter = "0"
    k.formatWidth = 7
    let lines : [String] = [
      ((0 ..< 18000).map { k.string(from: NSNumber(value: $0))! }).joined(separator: " ")+"\n",
      ((18000 ..< 36000).map { k.string(from: NSNumber(value: $0))! }).joined(separator: " ")+"\n",
      ((36000 ..< 54000).map { k.string(from: NSNumber(value: $0))! }).joined(separator: " ")+"\n",
    ]
    
    // FIXME: why didn't this work with pipe?
    let p = ShellProcess(ex, "-r")
    let of = try tmpfile("outfile", "")
    let ofh = try FileHandle(forWritingTo: of)
    await p.setOutput(ofh)
    let (r, _, _) = try await p.run( lines.joined() )
    #expect(r == 0)
    let j = try String(contentsOf: of, encoding: .utf8)
    #expect( j == lines.reversed().joined() )
  }

  @Test("Reverse a long file and print the last 135782 bytes") func longfile_rc135782() async throws {
    let k = NumberFormatter()
    k.paddingCharacter = "0"
    k.formatWidth = 63
    let i = ((0 ..< 9000).map { k.string(from: NSNumber(value: $0))!+"\n" }).joined()
    /*
     let inf = FileManager.default.temporaryDirectory.appendingPathComponent("try inFile")
     try i.write(to: inf, atomically: true, encoding: .utf8)
     */
    // FIXME: doesnt work with pipe output -- would work with file
    let p = ShellProcess(ex, "-rc135782")
    let (r, j, _) = try await p.run(i)
    #expect(r == 0)
    let o = ((stride(from: 8999, to: 0, by: -1).prefix(2121)).map { k.string(from: NSNumber(value: $0))!+"\n"}).joined() + "0000000000000000000000000000000006878\n"
    print(j!.count, o.count)
    #expect( j == o )
  }
  
  @Test("Reverse a long file with extremely long lines and print the last 145,782 bytes") func longfile_rc145782_longlines() async throws {
    let k = NumberFormatter()
    k.paddingCharacter = "0"
    k.formatWidth = 7

/*    let lines : [String] = [
      ((0 ..< 18000).map { k.string(from: NSNumber(value: $0))! }).joined(separator: " ")+"\n",
      ((18000 ..< 36000).map { k.string(from: NSNumber(value: $0))! }).joined(separator: " ")+"\n",
      ((36000 ..< 54000).map { k.string(from: NSNumber(value: $0))! }).joined(separator: " ")+"\n",
    ]
  */
    
    let lines : [String] = [
      ((0..<18000).map { String(format: "%07d", $0)} ).joined(separator: " ")+"\n",
      ((18000..<36000).map { String(format: "%07d", $0)}).joined(separator: " ")+"\n",
        ((36000..<54000).map { String(format: "%07d", $0)}).joined(separator: " ") + "\n",
    ]
    
    let p = ShellProcess(ex, "-rc145782")
    let (r, j, _) = try await p.run(lines.joined() )
    #expect(r == 0)
    
//    let ro = ((35778..<(35778+222)).map { k.string(from: NSNumber(value: $0) )!}).joined(separator: " ")+"\n"
    let ro = ((35778..<(35778+222)).map { String(format: "%07d", $0) }).joined(separator: " ")
    
    let o = lines[2] + "35777 " + ro + "\n"
    
    print(j!.count, o.count)
    #expect( j == o )
  }

  @Test("Reverse a long file and print the last 2,500 lines") func longfile_rn2500() async throws {
    let k = NumberFormatter()
    k.paddingCharacter = "0"
    k.formatWidth = 63
    let i = ((0 ..< 9000).map { k.string(from: NSNumber(value: $0))!+"\n" }).joined()
    
    // FIXME: why didn't this work with pipe
    let p = ShellProcess(ex, "-rn2500")
    let of = try tmpfile("outfile", "")
    let ofh = try FileHandle(forWritingTo: of)
    await p.setOutput(ofh)
    let (r, _, _) = try await p.run(i)
    let j = try String(contentsOf: of, encoding: .utf8)
    
    #expect(r == 0)
    let o = ((stride(from: 8999, to: 0, by: -1).prefix(2500)).map { k.string(from: NSNumber(value: $0))!+"\n"}).joined()
    print(j.count, o.count)
    #expect( j == o )
  }
  
  @Test("Do not print bogus errno based output on short writes", .disabled("not implemented")) func broken_pipe() async throws {
    // Not yet implemented
    #expect(false)
  }
  
  @Test("Check basic operations on standard input", .disabled("all the operations use standard input")) func stdin() async throws {
    // Not yet implemented
    #expect(false)
  }
  
  @Test("Basic regression test for -f") func follow() async throws {
    let inf = try tmpfile("try inFile",  "1\n2\n3\n")
    let inh = try FileHandle(forWritingTo: inf)

    let p = ShellProcess(ex, "-F", inf.relativePath)
    try await p.theLaunch()

    try await Task.sleep(nanoseconds: UInt64(Double(NSEC_PER_SEC) * 0.1))
    let m = await p.midCapture()
    let k = String(data: m, encoding: .utf8)!
    try inh.seekToEnd()
    try inh.write(contentsOf: "4\n5\n".data(using:.utf8)! )

    try await Task.sleep(nanoseconds: UInt64(Double(NSEC_PER_SEC) * 0.2))
    let k2 = String(data: await p.midCapture(), encoding: .utf8)!

    #expect(k == "1\n2\n3\n")
    #expect(k2 == k + "4\n5\n")
    await p.interrupt()
    rm(inf)
  }
  
  @Test("Verify that -f works with files piped to standard input") func follow_stdin() async throws {
    let p = ShellProcess(ex, "-f")

    let inf = try tmpfile("try inFile", "1\n2\n3\n")

    Task.detached {
      let fh = try FileHandle(forReadingFrom: inf)
      try await p.run(fh)
      
      
//        AsyncDataActor([ "1\n2\n3\n".data(using: .utf8)!, "4\n5\n".data(using: .utf8)!]).stream)
    }

    try await Task.sleep(nanoseconds: UInt64(Double(NSEC_PER_SEC) * 0.1))
    let m = await p.midCapture()
    let k = String(data: m, encoding: .utf8)!
    
    let fh2 = try FileHandle(forWritingTo: inf)
    try fh2.seekToEnd()
    try fh2.write(contentsOf: "4\n5\n".data(using: .utf8)!)
    
    try await Task.sleep(nanoseconds: UInt64(Double(NSEC_PER_SEC) * 0.1))
    let m2 = await p.midCapture()
    let k2 = String(data: m2, encoding: .utf8)!

    #expect(k == "1\n2\n3\n")
    #expect(k2 == "1\n2\n3\n4\n5\n")
    await p.interrupt()
    
    rm(inf)

  }

  @Test("Verify that -F works when a file is created") func follow_create() async throws {

    let inf = try tmpfile("try inFile", Data())
    rm(inf)
    
    let p = ShellProcess(ex, "-F", inf.relativePath)

    Task.detached {
       try await p.run()
    }

    try await Task.sleep(nanoseconds: UInt64(Double(NSEC_PER_SEC) * 1))

    try "1\n2\n3\n4\n5\n".write(to: inf, atomically: true, encoding: .utf8)

    try await Task.sleep(nanoseconds: UInt64(Double(NSEC_PER_SEC) * 1))
    let m = await p.midCapture()
    let k = String(data: m, encoding: .utf8)!
    
    #expect(k == "1\n2\n3\n4\n5\n")
    await p.interrupt()
  }

  @Test("Verify that -F works when a file is replaced") func follow_rename() async throws {

    let inf = try tmpfile("try inFile", "1\n2\n3\n")
    let p = ShellProcess(ex, "-F", inf.relativePath)

    Task.detached {
       try await p.run()
    }

    try await Task.sleep(nanoseconds: UInt64(Double(NSEC_PER_SEC) * 1))

    let inf2 = try tmpfile("infile_new", "4\n5\n")
    let inf3 = try tmpfile("infile_old", Data())
    rm(inf3)
    try FileManager.default.moveItem(at: inf, to: inf3)
    try FileManager.default.moveItem(at: inf2, to: inf)
    
    try await Task.sleep(nanoseconds: UInt64(Double(NSEC_PER_SEC) * 1))

    let m = await p.midCapture()
    let k = String(data: m, encoding: .utf8)!
    
    #expect(k == "1\n2\n3\n4\n5\n")
    await p.interrupt()
    
    [inf, inf2, inf3].forEach { rm($0) }

  }

  @Test("Test tail(1)'s silent header feature") func silent_header() async throws {
    
    let f1 = ((1...11).map { String($0)+"\n" }).joined()
    let inf = try tmpfile("file1", f1)

    let f2 = ((2...12).map { String($0)+"\n" }).joined()
    let inf2 = try tmpfile("file2", f2)
    
    let p = ShellProcess(ex, "-q", inf.relativePath, inf2.relativePath)
    let (r, j, _) = try await p.run()
    #expect(r == 0)
    #expect(j == String(f1.dropFirst(2)+f2.dropFirst(2)) )
    
    rm(inf)
    rm(inf2)
  }

  @Test("Test tail(1)'s verbose header feature") func verbose_header() async throws {
    
    let f1 = ((1...11).map { String($0)+"\n" }).joined()
    let inf = try tmpfile("file1", f1)

    let p = ShellProcess(ex, "-v", inf.relativePath)
    let (r, j, _) = try await p.run()
    #expect(r == 0)
    #expect(j == "==> \(inf.relativePath) <==\n"+f1.dropFirst(2) )
    
    rm(inf)

  }

  @Test("Test tail(1)'s SI number feature") func si_number() async throws {
    
    
    let f1 = Array(repeating: "aaaaaaa\n", count: 129).joined()
    let inf = try tmpfile("file1", f1)

    let p = ShellProcess(ex, "-c", "1k", inf.relativePath)
    let (r, j, _) = try await p.run()
    #expect(r == 0)
    #expect(j == Array(repeating: "aaaaaaa\n", count: 128).joined() )
    
    let f2 = ((1...1025).map { String($0)+"\n" }).joined()
    try f2.write(to: inf, atomically: true, encoding: .utf8)
    
    let p2 = ShellProcess(ex, "-n", "1k", inf.relativePath)
    let (r2, j2, _) = try await p2.run()
    #expect(r2 == 0)
    #expect(j2 == ((2...1025).map { String($0)+"\n" }).joined() )
    
    rm(inf)
  }

  @Test("File does not end in newline") func no_lf_at_eof() async throws {
    
    let f1 = "a\nb\nc"
    let inf = try tmpfile("try inFile", f1)

    let p1 = ShellProcess(ex, "-1", inf.relativePath)
    let (r1, j1, _) = try await p1.run()
    #expect(r1 == 0)
    #expect(j1 == "c")
    
    let p2 = ShellProcess(ex, "-2", inf.relativePath)
    let (r2, j2, _) = try await p2.run()
    #expect(r2 == 0)
    #expect(j2 == "b\nc")
    
    let p3 = ShellProcess(ex, "-3", inf.relativePath)
    let (r3, j3, _) = try await p3.run()
    #expect(r3 == 0)
    #expect(j3 == "a\nb\nc")
    
    let p4 = ShellProcess(ex, "-4", inf.relativePath)
    let (r4, j4, _) = try await p4.run()
    #expect(r4 == 0)
    #expect(j4 == "a\nb\nc")
    
    rm(inf)
    
  }
  
  // ====================================================
  
  @Test("rdar://problem/96169775 - verify that the BOF is handled properly") func blkbof() async throws {
    
    let f1 = "first line\nsecond line\n"
    let inf = try tmpfile("blkbof.in", f1)

    var buf : stat = stat()
    let s = stat(inf.path, &buf)
    
    let blksiz = buf.st_blksize
    let cursize = buf.st_size
        
    let sizeleft = Int(blksiz) - Int(cursize) - 1
    let f2 = String(repeating: "1", count: sizeleft) + "\n"
    
    let infh = try FileHandle(forWritingTo: inf)
    infh.seekToEndOfFile()
    infh.write( f2.data(using: .utf8)!)
    
    let p = ShellProcess(ex, "-n", "3", inf.relativePath)
    let (r, j, _) = try await p.run()
    #expect(r == 0)
    #expect(j == f1 + f2)
    
    rm(inf)

  }

  @Test("Regression test for radr://13271328") func radr_13271328() async throws {
    
    let inf = try tmpfile("blkbof.in", "")
    var buf : stat = stat()
    let s = stat(inf.relativePath, &buf)
    let blksiz = buf.st_blksize
    let cursize = buf.st_size
    
    let linelen = Int(blksiz) * 3 / 2
    

    let f2 = String(repeating: "a", count: linelen) + "\n" +
    String(repeating: "b", count: linelen) + "\n"
    
    let infh = try FileHandle(forWritingTo: inf)
    try infh.seekToEnd()
    infh.write( f2.data(using: .utf8)!)
    
    let p = ShellProcess(ex, "-1", inf.relativePath)
    let (r, j, _) = try await p.run()
    #expect(r == 0)
    #expect( (j!.count { $0 == "\n"}) == 1)
    
    rm(inf)

  }


  
}


// Generated by Robert "r0ml" Lefkowitz <code@liberally.net> in 2024
// from a file containing the following notice:

/*
  Copyright (c) 2008, 2009, 2010 The NetBSD Foundation, Inc.
  All rights reserved.
 
  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in the
     documentation and/or other materials provided with the distribution.
 
  THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
  ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
  BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
 
 */

import Testing
import TestSupport
import Foundation

class sortTest : ShellTest {
  let cmd = "sort"
  let suite = "sortTest"
  
  @Test("Basic functionality test") func basic() async throws {
    let i = """
z b m f
y c o e
x a n h
x a n g

"""
    let o = """
x a n g
x a n h
y c o e
z b m f

"""
    try await run(withStdin: i, output: o)
  }
  
  @Test("Tests sorting an empty file") func empty() async throws {
    try await run(output: "")
    try await run(output: "", args: "-c")
    try await run(output: "", args: "-c", "-u")
  }
  
  @Test("Determination of end of option list", .disabled("need to figure out how to test this")) func end_of_options() async throws {
    //    echo x >-k
    //    atf_check -o file:-k -x "sort -- -k </dev/null"
    //    atf_check -s not-exit:1 -e ignore -x "sort - -c </dev/null"
    
  }
  
  @Test("Tests with missing new line in input file")
  func missing_newline() async throws {
    try await run(withStdin: "x", output: "x\n")
  }
  
  @Test("Tests the behavior of null bytes")
  func null_bytes() async throws {
    try await run(withStdin: "\0b\n\0a\n", output: "\0a\n\0b\n")
  }
  
  @Test("Tests long lines and keys")
  func long_records() async throws {
    let ip = String(repeating: "x", count: 4096)
    let i = ((15...25).map { ip+String($0)+"\n" })
    try await run(withStdin: i.joined(), output: i.reversed().joined(), args: "-r")
    
    // FIXME: when input passed through pipe, fails
    let inf = try tmpfile("in", i.joined())
    try await run(output: i.reversed().joined(), args: "-k", "1,1r", "-k", "1", inf)
  }
  
  @Test("Tests with a long file to try to force intermediate files")
  func long_file() async throws {
    let dat = (1...20000).map {_ in String(Int.random(in: 1...20000)) + "\n" }
    let inf = try tmpfile("in", dat.joined() )
    let dats = dat.sorted()
    let datu = Array(Set(dat)).sorted()
    try await run(output: dats.reversed().joined(), args: "-r", inf)
    try await run(output: datu.reversed().joined(), args: "-u", "-r", inf)
  }
  
  @Test("Tests with files containing non-printable/extended characters")
  func any_char() async throws {
    let a = try inFile("d_any_char_in.txt")
    let b = try fileData(suite, "d_any_char_dflag_out.txt")
    try await run(output:b, args: "-d", "-k", "2", a)
    
    let c = try fileData(suite, "d_any_char_fflag_out.txt")
    try await run(output: c, args: "-f", "-k", "2", a)
    
    let d = try fileData(suite, "d_any_char_iflag_out.txt")
    try await run(output: d, args: "-i", "-k", "2", a)
  }
  
  @Test("Tests the -b flag")
  func bflag() async throws {
    
  }
  
  @Test("Tests the -c flag")
  func cflag() async throws {
    
  }
  
  
  @Test("Tests the -k flag with one field")
  func kflag_one_field() async throws {
    
  }
  
  @Test("Test the -k flag with two fields")
  func kflag_two_fields() async throws {
    
  }
  
  @Test("Test the -k flag with many fields")
  func kflag_many_fields() async throws {
    
  }
  
  @Test("Test the -k flag with out of bounds fields")
  func kflag_outofbounds() async throws {
    
  }
  
  @Test("Test the -k flag with apparently nonmonotone field specs")
  func kflag_nonmonotone() async throws {
    
  }
  
  @Test("Test the -k flag field limits")
  func kflag_limits() async throws {
    
  }
  
  @Test("Test the -k flag with various alpha fields")
  func kflag_alpha() async throws {
    
  }
  
  @Test("Test the -k flag with a field without end")
  func kflag_no_end() async throws {
    
  }
  
  @Test("Tests the -m flag")
  func mflag() async throws {
    
  }
  
  
  @Test("Tests the -m flag together with -u")
  func mflag_uflag() async throws {
    
  }
  
  @Test("Tests that the -m flag together with -u picks the first among equals")
  func mflag_uflag_first() async throws {
    
  }
  
  @Test("Tests the -n flag")
  func nflag() async throws {
    
  }
  
  @Test("Tests the -n and -r flag combination")
  func nflag_rflag() async throws {
    
  }
  
  @Test("Tests the -o flag")
  func oflag() async throws {
    
  }
  
  @Test("Tests the -o flag after the file names")
  func oflag_displaced() async throws {
    
  }
  
  @Test("Tests the -r flag")
  func rflag() async throws {
    
  }
  
  @Test("Tests the -s flag")
  func sflag() async throws {
    
  }
  
  @Test("Tests the -s flag with multiple files")
  func sflag_many_files() async throws {
    
  }
  
  @Test("Tests the -t flag")
  func tflag() async throws {
    
  }
  
  @Test("Tests the -t flag with a character as the delimiter")
  func tflag_alphabetic() async throws {
    
  }
  
  @Test("Tests the -t flag with character positions if fields")
  func tflag_char_pos() async throws {
    
  }
  
  @Test("Tests the -t flag with spaces and tabs as the delimiter")
  func tflag_whitespace() async throws {
    
  }
  
  
  @Test("Tests the -u flag")
  func uflag() async throws {
    
  }
  
  @Test("Tests the -u and -r flag combination")
  func uflag_rflag() async throws {
    
  }
  
  @Test("Tests +- addressing: +1 should become -k2.1")
  func plus_one() async throws {
    
  }
  
  @Test("Tests +- addressing: +1 -2 should become -k2.1,2.0")
  func plus_one_minus_two() async throws {
    
  }
  
  @Test("Tests +- addressing: -- +0 raised a '-k1.1: No such file or directory' error")
  func plus_zero() async throws {
    
  }
  
  @Test("Tests +- addressing: apparently nonmonotone field specs")
  func plus_monotone() async throws {
    
  }
  
  @Test("Tests +- addressing: intermediate wrong behavior that raised a '+0: No such file or directory' error")
  func plus_bad_tempfile() async throws {
    
  }
  
  @Test("Tests +- addressing: invalid record delimiter")
  func plus_rflag_invalid() async throws {
    
  }
  
  @Test("Tests +- addressing: using -T caused a 'No such file or directory' error")
  func plus_tflag() async throws {
    
  }
  
  @Test("Tests +- addressing: field without end")
  func plus_no_end() async throws {
    
  }
  
}

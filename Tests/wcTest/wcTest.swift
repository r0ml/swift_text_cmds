// Generated by Robert "r0ml" Lefkowitz <code@liberally.net> in 2024
// from a file containing the following notice:

/*
  Copyright (c) 2023 Klara, Inc.

  SPDX-License-Identifier: BSD-2-Clause
*/

import ShellTesting

@Suite() class wcTest : ShellTest {
  let tv="""
Der bode en underlig grÃ¥sprÃ¦ngt en
pÃ¥ den yderste nÃ¸gne Ã¸; â€“
han gjorde visst intet menneske mÃ©n
hverken pÃ¥ land eller sjÃ¸;
dog stundom gnistred hans Ã¸jne stygt, â€“
helst mod uroligt vejr, â€“
og da mente folk, at han var forrykt,
og da var der fÃ¥, som uden frykt
kom Terje Vigen nÃ¦r.

"""

  let tvl=10
  let tvw=55
  let tvc=300
  let tvm=283
  let tvcL=42
  let tvmL=39

  let cmd = "wc"
  let suiteBundle = "text_cmds_wcTest"

  func check(_ i : String, _ a : Int, _ b : Int, _ c : Int, _ d : Int? = nil) async throws {
    try await run(withStdin: i) { o in
      let k = o.string.matches(of: /^ +(\d+) +(\d+) +(\d+)\n$/)
      #expect(k.count == 1 &&
              Int(k[0].output.1)! == a &&
              Int(k[0].output.2)! == b &&
              Int(k[0].output.3)! == c )
    }
    try await run(args: "-l") { po in
      let k1 = po.string.matches(of: /^ +(\d+)\n$/)
      #expect(k1.count == 1 &&
              Int(k1[0].output.1)! == a )
    }
    try await run(args: "-w") { po2 in
      let k2 = po2.string.matches(of: /^ +(\d+)\n$/)
      #expect(k2.count == 1 &&
              Int(k2[0].output.1)! == b)
    }
    try await run(args: "-c") { po3 in
      let k3 = po3.string.matches(of: /^ +(\d+)\n$/)
      #expect(k3.count == 1 &&
              Int(k3[0].output.1)! == c, "\(c)")
    }
/*
    let (_, o4, _) = try run(cl, ex, ["-m"], i)
    let k4 = o4!.matches(of: /^ +(\d)\n$/)
    #expect(k4.count == 1 &&
           Int(k4[0].output.1)! == d ?? c)
 */
  }
  
  @Test("Basic test case") func basic() async throws {
    try await check("a b\n", 1, 2, 4)
}

  @Test("Input containing only blank lines") func blank() async throws {
    try await check("\n\n\n", 3, 0, 3)
  }

  @Test("Empty input") func empty() async throws {
    try await check("", 0, 0, 0)
  }

  @Test("Invalid multibye input") func invalid() async throws {
    let i = try "a\u{ff}b\n".isoLatin1()

    try await run(withStdin: i, args: "-m", env: ["LC_ALL":"UTF-8"]) {po in
      let k = po.string.matches(of: /^ +(\d+)\n$/)
      #expect(k.count == 1)

      if k.count == 1 {
        #expect(Int(k[0].output.1)! == 4)
      }
      #expect(po.error.matches(of: /Illegal byte sequence/).count == 1)
    }
  }

  @Test("Multiline, multibyte input") func multiline() async throws {
    try await check(tv+"\n", tvl, tvw, tvc, tvm)
  }

  @Test("Multiline input exceeding the input buffer size") func multiline_repeated() async throws {
    let c = 1000
    let tvx = Array(repeating: tv+"\n", count: c).joined()
    try await check(tvx, tvl * c, tvw * c, tvc * c, tvm * c)
  }

  @Test("Input containing NUL") func nul() async throws {
    try await check("a\0b\n", 1, 1, 4)
  }

  @Test("Multibyte sequence across buffer boundary") func poop() async throws {
    let p = "ðŸ’©.ðŸ’©.ðŸ’©.ðŸ’©.ðŸ’©.ðŸ’©.ðŸ’©.ðŸ’©.ðŸ’©.ðŸ’©.ðŸ’©.ðŸ’©.ðŸ’©.ðŸ’©.ðŸ’©.ðŸ’©\n"
    let MAXBSIZE=1048576
    let c = MAXBSIZE / p.count
    let foo = Array(repeating: p, count: c).joined()
    try await check(foo, c, c, c * 80, c * 32 )
  }

  @Test func total() async throws {
    let f = try tmpfile("foo", tv+"\n")
    let f2 = try tmpfile("bar", tv+"\n")

    defer {
      rm(f, f2)
    }
    
    try await run(args: f, f2) { po in
      let ll = po.string.split(separator: "\n", omittingEmptySubsequences: true).last

      // More than one line of output
      #expect(ll != nil)

      if let ll {
        let k = ll.matches(of: /^\s+(\d+)\s+(\d+)\s+(\d+)\s+total$/)

        try #require(!k.isEmpty)
        #expect( Int((k.first!.output.1))! == 2 * self.tvl )
        #expect( Int(k.first!.output.2)! == 2 * self.tvw )
        #expect( Int(k.first!.output.3)! == 2 * self.tvc )
      }
    }
  }

  @Test("Input not ending in newline") func unterminated() async throws {
    try await check("a b", 0, 2, 3)
  }

  @Test("Trigger usage message") func usage() async throws {
    try await run(args: "-?") { po in
      #expect(po.code == 1)
      #expect( po.error.split(separator: "\n", omittingEmptySubsequences: true).map { $0.hasPrefix("usage:") }.contains(true) )
    }
  }

  @Test("Input containing only whitespace and newlines") func whitespace() async throws {
    try await check("\n \n\t\n", 3, 0, 5)
  }

}



